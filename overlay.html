<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Overlay Final Gold V7 - laumehdi</title>
  <style>
    html, body { 
      margin: 0; padding: 0; background: transparent !important; 
      overflow: hidden; width: 1920px; height: 1080px;
      font-family: 'Segoe UI', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
    }
    
    #container { 
      position: absolute; width: 100%; height: 100%; 
      top: 0; left: 0; pointer-events: none; 
    }

    #status {
      position: absolute; top: 10px; left: 10px;
      color: #ffcc00; font-weight: bold; font-size: 24px;
      text-shadow: 2px 2px 0 #000;
      z-index: 99999;
      font-family: monospace;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      display: none; 
    }
    
    .item { 
      position: absolute; 
      top: 0; left: 0; 
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 150px;
      will-change: transform; 
    }

    canvas { 
      image-rendering: pixelated; 
      width: 150px; height: 150px; 
      background: transparent; 
      transition: transform 0.3s; 
    }

    @keyframes jumpBounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-30px); } 
    }

    /* El salto solo ocurre si tiene la clase jumping */
    .jumping canvas {
      animation: jumpBounce 0.8s ease-in-out infinite;
    }

    .is-sub canvas {
      filter: drop-shadow(0 0 2px #FFD700) drop-shadow(0 0 8px #FFD700);
      animation: glowPulse 2s infinite alternate;
    }
    
    /* Si es sub Y ademas está saltando (en el carril), combinamos animaciones */
    .jumping.is-sub canvas {
       animation: jumpBounce 0.8s ease-in-out infinite, glowPulse 2s infinite alternate;
    }

    @keyframes glowPulse {
      from { filter: drop-shadow(0 0 2px #FFD700) drop-shadow(0 0 6px #FFD700); }
      to   { filter: drop-shadow(0 0 2px #FFD700) drop-shadow(0 0 12px #FFA500); }
    }

    .nick { 
      color: white; 
      font-weight: 900;
      font-size: 20px; 
      width: 250px; 
      text-align: center;
      margin-top: 2px;
      white-space: nowrap;
      text-shadow: 
        2px 0 0 #000, -2px 0 0 #000, 
        0 2px 0 #000, 0 -2px 0 #000, 
        2px 2px 0 #000;
    }

    .is-sub .nick {
      color: #FFD700 !important; 
      text-shadow: 
        2px 0 0 #000, -2px 0 0 #000, 
        0 2px 0 #000, 0 -2px 0 #000,
        0 0 10px #FFD700, 
        0 0 20px #FFD700;
    }

    .showcase {
      position: fixed !important; 
      top: 50% !important; 
      left: 50% !important;
      z-index: 99999 !important;
      animation: superDance 0.8s infinite ease-in-out !important;
      filter: drop-shadow(0 0 25px white); 
    }

    @keyframes superDance {
      0%   { transform: translate(-50%, -50%) scale(4.5) rotate(0deg); }
      25%  { transform: translate(-50%, -50%) scale(4.8) rotate(-8deg); }
      50%  { transform: translate(-50%, -50%) scale(4.5) rotate(0deg) translateY(-20px); } 
      75%  { transform: translate(-50%, -50%) scale(4.8) rotate(8deg); }
      100% { transform: translate(-50%, -50%) scale(4.5) rotate(0deg); }
    }

    .hidden { display: none !important; }
    .waiting { opacity: 0; } 
  </style>
</head>
<body>
  <div id="status">CARGANDO...</div>
  <div id="container"></div>

  <script>
    // --- CONFIGURACIÓN ---
    const CHANNEL = 'laumehdi'; 
    const LIFE_TIME_MINUTES = 50; 
    // ---------------------

    const LIFE_TIME_MS = LIFE_TIME_MINUTES * 60 * 1000;
    const colors = ['transparent','#000000','#aa0000','#00aa00','#aa5500','#0000aa','#aa00aa','#00aaaa','#aaaaaa','#555555','#ff5555','#55ff55','#ffff55','#5555ff','#ff55ff','#55ffff','#ffffff'];
    
    let drawings = []; 
    let testMode = false;
    let rainMode = false; 
    let subQueue = [];
    let isShowcaseBusy = false;
    let ws = null;
    let reconnectInterval = null;
    let activeCodes = new Set(); 

    const LANES = [5, 35, 65, 95]; 
    const SPEEDS = [2, 3.5, 2.5, 4.5];
    const Z_INDEXES = [5, 20, 10, 30];

    // ANIMACIÓN PRINCIPAL
    function animate() {
      const now = Date.now();

      for (let i = drawings.length - 1; i >= 0; i--) {
        let d = drawings[i];
        
        if (d.el.classList.contains('showcase') || d.el.classList.contains('hidden')) continue;
        
        if (d.el.classList.contains('waiting')) {
             d.el.style.transform = 'translate3d(-500px, -500px, 0)';
             continue;
        }

        // === MODO LLUVIA INFINITA ===
        if (rainMode) {
            d.el.style.opacity = 1; 

            // Caída suave vertical
            d.y += d.rainSpeed; 
            
            // Vaivén suave horizontal
            const sway = Math.sin((now / 800) + d.rainPhase) * 20; 
            d.x = d.rainOriginX + sway;

            // Render
            d.el.style.transform = 'translate3d(' + d.x + 'px, ' + d.y + 'px, 0)';

            // BUCLE
            if (d.y > 1100) {
                d.y = -180; 
                d.rainOriginX = Math.random() * 1800; 
            }
            continue; 
        }
        // ============================

        // --- MUERTE NATURAL (50 min) ---
        if (!d.dying && !testMode && (now - d.createdAt > LIFE_TIME_MS)) {
            d.dying = true;
            d.vy = 0; d.rot = 0;
        }

        if (d.dying) {
            d.vy += 0.5; 
            d.y += d.vy; 
            d.rot += 5;
            d.el.style.transform = 'translate3d(' + d.x + 'px, ' + d.y + 'px, 0) rotate(' + d.rot + 'deg)';
            d.el.style.opacity = (1 - (d.y / 1500)); 

            if (d.y > 1200) {
                d.el.remove();
                if(d.code) activeCodes.delete(d.code);
                drawings.splice(i, 1);
                continue;
            }
        } else {
            // Movimiento Normal
            d.el.style.opacity = 1;
            d.x += d.speed;
            if (d.x > 2200) { 
              let minX = -200;
              for (let j = 0; j < drawings.length; j++) {
                if (drawings[j].lane === d.lane && drawings[j].x < minX) {
                  minX = drawings[j].x;
                }
              }
              d.x = minX - 300; 
            }
            d.el.style.transform = 'translate3d(' + d.x + 'px, ' + d.y + 'px, 0)';
        }
      }
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // CONEXIÓN
    function connectTwitch() {
      if (ws) { try { ws.close(); } catch(e){} }
      const statusEl = document.getElementById('status');
      statusEl.style.display = 'block';
      statusEl.innerText = "CONECTANDO...";
      statusEl.style.color = "#ffcc00";

      ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

      ws.onopen = function() {
        console.log("WS Conectado");
        statusEl.innerText = "¡CONECTADO!";
        statusEl.style.color = "#00ff00"; 
        setTimeout(function() { statusEl.style.display = 'none'; }, 3000);
        ws.send('CAP REQ :twitch.tv/tags');
        ws.send('PASS oauth:none');
        ws.send('NICK justinfan' + Math.floor(Math.random()*99999));
        ws.send('JOIN #' + CHANNEL.toLowerCase());
        if(reconnectInterval) clearInterval(reconnectInterval);
      };

      ws.onerror = function(e) { statusEl.innerText = "REINTENTANDO..."; statusEl.style.color = "red"; };
      ws.onclose = function() { statusEl.innerText = "DESCONECTADO"; statusEl.style.color = "red"; reconnectInterval = setTimeout(connectTwitch, 3000); };
      ws.onmessage = function(e) { handleMessage(e.data); };
    }

    function handleMessage(data) {
      if (data.indexOf('PING') !== -1) { ws.send('PONG :tmi.twitch.tv'); return; }
      if (data.indexOf('PRIVMSG') !== -1) {
        const parts = data.split('PRIVMSG #' + CHANNEL.toLowerCase() + ' :');
        if (!parts[1]) return;
        const msg = parts[1].trim();
        const rawTags = data.split('PRIVMSG')[0];
        const userMatch = data.match(/:(\w+)!/);
        const user = userMatch ? userMatch[1].toLowerCase() : 'unknown';
        const isSub = rawTags.indexOf('subscriber=1') !== -1 || rawTags.indexOf('badges=subscriber') !== -1 || rawTags.indexOf('/founder') !== -1;
        const isAdmin = (user === CHANNEL.toLowerCase());

        if (msg.indexOf('!dibujar ') === 0) {
          const codeParts = msg.substring(9).trim().split(' ');
          const code = codeParts[0]; 
          if(code) createDrawing(user, code, isSub, false);
        } else if (msg.indexOf('!borrar') === 0) {
          const splitMsg = msg.split(' ');
          const target = splitMsg[1] ? splitMsg[1].replace('@','') : user;
          removeDrawing(isAdmin ? target : user);
        } else if (msg === '!testpixel' && isAdmin) {
          toggleTest();
        } else if (msg === '!fin' && isAdmin) {
          toggleRain();
        }
      }
    }

    function toggleRain() {
        rainMode = !rainMode;
        if (rainMode) {
            drawings.forEach(d => {
                d.rainOriginX = d.x; 
                d.rainSpeed = 0.8 + Math.random() * 1.7; 
                d.rainPhase = Math.random() * Math.PI * 2; 
            });
        } else {
            drawings.forEach(d => {
                d.y = LANES[d.lane]; 
            });
        }
    }

    function createDrawing(user, fullCode, isSub, isTest, forceX) {
      if (!isTest && activeCodes.has(fullCode)) return;

      try {
        let pixelData = [];
        let finalPalette = []; 
        const isV2 = fullCode.indexOf('v2') === 0; 

        if (isV2) {
          const cleanCode = fullCode.substring(2);
          const parts = cleanCode.split('_');
          const headerHex = parts[0];
          const payload = parts[1];
          if (!headerHex || !payload) return;

          finalPalette.push('transparent'); 
          for (let i = 0; i < headerHex.length; i += 6) {
            finalPalette.push('#' + headerHex.substring(i, i+6));
          }

          const binaryString = atob(payload);
          for (let i = 0; i < binaryString.length; i++) {
            const byte = binaryString.charCodeAt(i);
            pixelData.push((byte >> 4) & 0x0F);
            pixelData.push(byte & 0x0F);
          }
        } else {
          if(fullCode.indexOf('_') === -1) return;
          const parts = fullCode.split('_');
          const header = parts[0];
          const payload = parts[1];
          if (!header || !payload) return;
          for (let i = 0; i < payload.length; i += 2) {
            const colorIdx = parseInt(payload[i], 16);
            const count = parseInt(payload[i+1], 36);
            if(isNaN(colorIdx) || isNaN(count)) continue;
            for (let j = 0; j < count; j++) { pixelData.push(colorIdx); }
          }
          const usedColorsIdx = [];
          for(let i=0; i < header.length; i++) {
            if (header[i] === '1' && header[i+1] === '0') { usedColorsIdx.push(16); i++; }
            else { usedColorsIdx.push(parseInt(header[i], 16)); }
          }
          for(let k=0; k<usedColorsIdx.length; k++) { finalPalette.push(colors[usedColorsIdx[k]] || 'transparent'); }
        }

        const itemEl = document.createElement('div');
        itemEl.className = 'item';
        
        const canvas = document.createElement('canvas');
        canvas.width = 16; canvas.height = 16;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 16, 16); 

        for (let k = 0; k < pixelData.length; k++) {
           const colorIndex = pixelData[k];
           if (isV2) {
               if (colorIndex > 0 && colorIndex < finalPalette.length) {
                   ctx.fillStyle = finalPalette[colorIndex];
                   ctx.fillRect(k % 16, Math.floor(k / 16), 1, 1);
               }
           } else {
               if(colorIndex < finalPalette.length) {
                   const color = finalPalette[colorIndex];
                   if(color !== 'transparent') {
                       ctx.fillStyle = color;
                       ctx.fillRect(k % 16, Math.floor(k / 16), 1, 1);
                   }
               }
           }
        }

        // 1. Configuración de SUBS
        if (isSub) {
            itemEl.classList.add('is-sub');
            if (!isTest) itemEl.classList.add('waiting');
        }

        // 2. Configuración de SALTO
        // SOLO LOS NORMALES saltan inmediatamente
        if (!isTest && !isSub) {
            itemEl.classList.add('jumping');
            setTimeout(() => { if (itemEl) itemEl.classList.remove('jumping'); }, 16000);
        }
        // (Los subs saltarán DESPUÉS de su baile, en processQueue)

        if (testMode && !isTest) itemEl.classList.add('hidden');
        itemEl.appendChild(canvas);
        const nickEl = document.createElement('div');
        nickEl.className = 'nick'; 
        nickEl.innerText = (isSub ? '⭐ ' : '') + user;
        itemEl.appendChild(nickEl);
        
        const laneIdx = drawings.length % 4;
        itemEl.style.zIndex = Z_INDEXES[laneIdx]; 
        document.getElementById('container').appendChild(itemEl);

        let obj = {
          el: itemEl,
          user: user,
          code: fullCode,
          lane: laneIdx,
          speed: SPEEDS[laneIdx],
          y: LANES[laneIdx],
          x: forceX !== undefined ? forceX : -400,
          isTest: isTest,
          createdAt: Date.now(),
          dying: false,
          rainOriginX: 0, 
          rainSpeed: 1, 
          rainPhase: 0
        };

        if (forceX === undefined) {
          let min = -200;
          drawings.forEach(function(d) { if(d.lane === laneIdx && d.x < min) min = d.x; });
          obj.x = min - 300;
        }
        
        obj.rainOriginX = obj.x;

        drawings.push(obj);
        if (!isTest) {
          activeCodes.add(fullCode);
          if (isSub) { subQueue.push(obj); processQueue(); }
        }
      } catch(e) { console.error("Error al crear dibujo:", e); }
    }

    function toggleTest() {
      if (!testMode) {
        testMode = true;
        drawings.forEach(function(d) { if(!d.isTest) d.el.classList.add('hidden'); });
        const code = "0ce_0m17081205120k210623042501220121042103210223012103230221022103220321032101230322022103210121062102210523022302210922042102120f150g170i";
        for (let i = 0; i < 20; i++) { createDrawing('Bot_' + i, code, (i % 3 === 0), true, (Math.random() * 1900)); }
      } else {
        testMode = false;
        let newDrawings = [];
        for(let k=0; k<drawings.length; k++){
            let d = drawings[k];
            if(d.isTest) { d.el.remove(); } else { d.el.classList.remove('hidden'); newDrawings.push(d); }
        }
        drawings = newDrawings;
      }
    }

    function processQueue() {
      if (!isShowcaseBusy && subQueue.length > 0) {
        isShowcaseBusy = true;
        const current = subQueue.shift();
        current.el.classList.remove('waiting', 'hidden');
        current.el.classList.add('showcase');
        current.el.style.transform = ''; 
        
        setTimeout(function() {
          current.el.classList.remove('showcase');
          let min = -200;
          drawings.forEach(function(d) { if(d.lane === current.lane && d.x < min) min = d.x; });
          current.x = min - 350;
          
          // --- AQUÍ EL SUB EMPIEZA A SALTAR EN EL CARRIL ---
          current.el.classList.add('jumping');
          setTimeout(() => { if (current.el) current.el.classList.remove('jumping'); }, 16000); 
          // ------------------------------------------------

          isShowcaseBusy = false;
          processQueue();
        }, 10000); 
      }
    }

    function removeDrawing(u) {
      for (let i = drawings.length - 1; i >= 0; i--) {
        if (drawings[i].user === u) {
          drawings[i].el.remove();
          if (drawings[i].code) activeCodes.delete(drawings[i].code);
          drawings.splice(i, 1);
        }
      }
    }

    connectTwitch();
  </script>
</body>
</html>
