<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Overlay Final Pro - laumehdi</title>
  <style>
    body { margin: 0; background: transparent; overflow: hidden; width: 1920px; height: 1080px; }
    #container { position: relative; width: 100%; height: 100%; }
    
    .item { 
      position: absolute; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      will-change: transform, left, top;
      transition: opacity 0.5s ease, transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* Animación de baile para el Showcase (Dibujo + Nick + Estrella) */
    @keyframes superDance {
      0% { transform: translate(-50%, -50%) scale(4) rotate(0deg); }
      25% { transform: translate(-50%, -52%) scale(4.1) rotate(4deg); }
      50% { transform: translate(-50%, -50%) scale(4) rotate(-4deg); }
      75% { transform: translate(-50%, -48%) scale(4.1) rotate(4deg); }
      100% { transform: translate(-50%, -50%) scale(4) rotate(0deg); }
    }

    /* Estilo VIP permanente para Subs (Brillo dorado) */
    .sub-active { 
      z-index: 999; 
      filter: drop-shadow(0 0 12px gold) drop-shadow(0 0 5px orange); 
    }

    /* Activación del baile en el medio */
    .showcase {
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      z-index: 10000 !important;
      animation: superDance 1s infinite ease-in-out !important;
    }

    .nick { 
      color: white; font-family: 'Arial Black', sans-serif; font-weight: 900; 
      margin-top: 2px; font-size: 25px; 
      text-shadow: -1.5px -1.5px 0 #000, 1.5px -1.5px 0 #000, -1.5px 1.5px 0 #000, 1.5px 1.5px 0 #000, 2px 2px 5px rgba(0,0,0,0.8);
    }

    .sub-active .nick::before { content: '⭐ '; color: gold; }

    .grid { display: grid; grid-template-columns: repeat(16, 12px); grid-template-rows: repeat(16, 12px); }
    .px { width: 13px; height: 13px; margin-right: -1px; margin-bottom: -1px; shape-rendering: crispEdges; }

    /* Ocultar dibujos en cola o durante el modo test */
    .waiting { display: none !important; }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    const CHANNEL = 'laumehdi'; 
    const colors = ['transparent','#000000','#aa0000','#00aa00','#aa5500','#0000aa','#aa00aa','#00aaaa','#aaaaaa','#555555','#ff5555','#55ff55','#ffff55','#5555ff','#ff55ff','#55ffff','#ffffff'];
    
    let globalSpeedMultiplier = 1;
    const baseSpeed = 2.2, spacing = 240, drawingsPerLayer = 15;
    const layerSpeedNuances = [1.0, 2.0, 1.3, 1.7, 1.1, 1.9];

    let drawings = [];
    let subQueue = [];
    let isShowcaseBusy = false;
    let debugModeActive = false;

    function animate() {
      drawings.forEach((d, index) => {
        if (d.el.classList.contains('showcase') || d.el.classList.contains('waiting')) return;

        const layerIndex = Math.floor(index / drawingsPerLayer);
        const nuance = layerSpeedNuances[layerIndex] || (1.1 + (Math.sqrt(layerIndex) % 1));
        d.x += baseSpeed * globalSpeedMultiplier * nuance;
        
        if (d.x > 1920) {
            const myStart = layerIndex * drawingsPerLayer;
            const myGroup = drawings.filter((o, i) => i >= myStart && i < myStart + drawingsPerLayer && !o.el.classList.contains('showcase') && !o.el.classList.contains('waiting'));
            let minX = 0;
            myGroup.forEach(other => { if(other.x < minX) minX = other.x; });
            d.x = minX - spacing; 
        }
        
        d.el.style.left = `${d.x}px`;
        d.el.style.top = `${60 + d.offsetY}px`;
        d.el.style.transform = `scale(${d.scale})`;
      });
      requestAnimationFrame(animate);
    }
    animate();

    const ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
    ws.onopen = () => {
      ws.send('CAP REQ :twitch.tv/tags');
      ws.send('PASS oauth:none');
      ws.send('NICK justinfan' + Math.floor(Math.random()*10000));
      ws.send(`JOIN #${CHANNEL}`);
    };

    ws.onmessage = (e) => {
      if (e.data.includes('PING')) ws.send('PONG :tmi.twitch.tv');
      if (e.data.includes('PRIVMSG')) {
        const parts = e.data.split('PRIVMSG #' + CHANNEL + ' :');
        const msg = parts[1] ? parts[1].trim() : '';
        const metadata = e.data.split(' ')[0];
        const userMatch = e.data.match(/:(\w+)!/);
        const user = userMatch ? userMatch[1].toLowerCase() : '';
        
        const isSub = metadata.includes('subscriber=1') || metadata.includes('badges=subscriber');
        const isAdmin = (user === CHANNEL || user === 'laumehdi');

        if (msg.startsWith('!dibujar ')) {
          createDrawing(user, msg.split(' ')[1], isSub);
        } 
        else if (msg === '!testpixel' && isAdmin) {
          runDebugTest();
        }
        else if (msg === '!limpiartodo' && isAdmin) {
            drawings.forEach(d => d.el.remove());
            drawings = []; subQueue = []; isShowcaseBusy = false;
        }
        else if (msg.startsWith('!borrar') && isAdmin) {
          const target = msg.replace('!borrar', '').replace('@', '').trim().toLowerCase();
          removeLastFromUser(target || user);
        }
      }
    };

    function createDrawing(user, fullCode, isSub, silent = false, isTest = false) {
      try {
        const [header, payload] = fullCode.split('_');
        const usedColors = [];
        for(let i=0; i < header.length; i++) {
          if (header[i] === '1' && header[i+1] === '0') { usedColors.push(16); i++; }
          else { usedColors.push(parseInt(header[i], 16)); }
        }

        const itemEl = document.createElement('div');
        itemEl.className = 'item';
        if (isSub) itemEl.classList.add('sub-active');

        // Si el test está activo y llega un dibujo REAL, lo ocultamos para que no moleste
        if (debugModeActive && !isTest) {
          itemEl.classList.add('waiting');
        } else if (isSub && !silent) {
          itemEl.classList.add('waiting'); // Subs reales van a la cola ocultos
        }

        const grid = document.createElement('div');
        grid.className = 'grid';
        for (let i = 0; i < payload.length; i += 2) {
          const colorIdx = parseInt(payload[i], 16);
          const count = parseInt(payload[i+1], 36);
          for (let j = 0; j < count; j++) {
            const px = document.createElement('div');
            px.className = 'px';
            px.style.backgroundColor = colors[usedColors[colorIdx]] || 'transparent';
            grid.appendChild(px);
          }
        }
        itemEl.appendChild(grid);
        const nickEl = document.createElement('div');
        nickEl.className = 'nick';
        nickEl.innerText = user;
        itemEl.appendChild(nickEl);
        document.getElementById('container').appendChild(itemEl);

        const drawingObj = { 
          el: itemEl, x: -spacing, user: user, 
          scale: 0.85 + (Math.random() * 0.3), 
          offsetY: (Math.random() * 50) - 25,
          isSub: isSub,
          isTest: isTest
        };
        drawings.push(drawingObj);

        if (isSub && !silent) {
          subQueue.push(drawingObj);
          processQueue();
        }
      } catch(err) {}
    }

    function processQueue() {
      if (!isShowcaseBusy && subQueue.length > 0) {
        isShowcaseBusy = true;
        const currentSub = subQueue.shift();
        currentSub.el.classList.remove('waiting');
        currentSub.el.classList.add('showcase');

        setTimeout(() => {
          currentSub.el.classList.remove('showcase');
          let currentMinX = 0;
          drawings.forEach(d => { if(!d.el.classList.contains('waiting') && d.x < currentMinX) currentMinX = d.x; });
          currentSub.x = currentMinX - spacing;
          isShowcaseBusy = false;
          processQueue();
        }, 10000);
      }
    }

    function runDebugTest() {
      if (debugModeActive) return;
      debugModeActive = true;

      // Ocultar dibujos reales actuales
      drawings.forEach(d => d.el.classList.add('waiting'));
      
      const testCode = "0ce_0m17081205120k210623042501220121042103210223012103230221022103220321032101230322022103210121062102210523022302210922042102120f150g170i";

      for (let i = 0; i < 40; i++) {
        const fakeUser = "User_" + Math.floor(Math.random() * 999);
        const fakeSub = Math.random() > 0.5;
        createDrawing(fakeUser, testCode, fakeSub, true, true);
      }

      setTimeout(() => {
        // Eliminar bots
        drawings = drawings.filter(d => {
          if (d.isTest) { d.el.remove(); return false; }
          return true;
        });

        // Restaurar todos los reales (viejos y los que llegaron durante el test)
        drawings.forEach(d => {
            // Si el dibujo real NO es un sub que está esperando en la cola de showcase, mostrarlo
            const isInSubQueue = subQueue.some(q => q === d);
            if (!isInSubQueue) {
                d.el.classList.remove('waiting');
            }
        });
        
        debugModeActive = false;
      }, 15000);
    }

    function removeLastFromUser(username) {
      for (let i = drawings.length - 1; i >= 0; i--) {
        if (drawings[i].user === username) {
          drawings[i].el.remove();
          drawings.splice(i, 1);
          subQueue = subQueue.filter(q => q.user !== username);
          break;
        }
      }
    }
  </script>
</body>
</html>
