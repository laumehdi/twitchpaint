<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Overlay Final Gold V2 - laumehdi</title>
  <style>
    html, body { 
      margin: 0; padding: 0; background: transparent !important; 
      overflow: hidden; width: 1920px; height: 1080px;
      font-family: 'Segoe UI', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
    }
    
    #container { 
      position: absolute; width: 100%; height: 100%; 
      top: 0; left: 0; pointer-events: none; 
    }

    #status {
      position: absolute; top: 10px; left: 10px;
      color: #ffcc00; font-weight: bold; font-size: 24px;
      text-shadow: 2px 2px 0 #000;
      z-index: 99999;
      font-family: monospace;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      display: none; 
    }
    
    /* EL DIBUJO BASE */
    .item { 
      position: absolute; 
      top: 0; left: 0; 
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 150px;
      will-change: transform; 
    }

    canvas { 
      image-rendering: pixelated; 
      width: 150px; height: 150px; 
      background: transparent; 
      /* Transición suave para cuando deje de saltar */
      transition: transform 0.3s; 
    }

    /* --- ANIMACIÓN DE SALTO (NUEVOS NO-SUBS) --- */
    @keyframes jumpBounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-30px); } /* Altura del salto */
    }

    /* Clase que se agrega temporalmente a los nuevos */
    .jumping canvas {
      animation: jumpBounce 0.8s ease-in-out infinite;
    }

    /* GLOW PARA EL DIBUJO DE SUBS */
    .is-sub canvas {
      filter: drop-shadow(0 0 2px #FFD700) drop-shadow(0 0 8px #FFD700);
      animation: glowPulse 2s infinite alternate;
    }

    @keyframes glowPulse {
      from { filter: drop-shadow(0 0 2px #FFD700) drop-shadow(0 0 6px #FFD700); }
      to   { filter: drop-shadow(0 0 2px #FFD700) drop-shadow(0 0 12px #FFA500); }
    }

    /* --- NOMBRE DE USUARIO --- */
    .nick { 
      color: white; 
      font-weight: 900;
      font-size: 20px; 
      width: 250px; 
      text-align: center;
      margin-top: 2px;
      white-space: nowrap;
      text-shadow: 
        2px 0 0 #000, -2px 0 0 #000, 
        0 2px 0 #000, 0 -2px 0 #000, 
        2px 2px 0 #000;
    }

    .is-sub .nick {
      color: #FFD700 !important; 
      text-shadow: 
        2px 0 0 #000, -2px 0 0 #000, 
        0 2px 0 #000, 0 -2px 0 #000,
        0 0 10px #FFD700, 
        0 0 20px #FFD700;
    }

    /* --- BAILE NUEVO (4.5x) --- */
    .showcase {
      position: fixed !important; 
      top: 50% !important; 
      left: 50% !important;
      z-index: 99999 !important;
      animation: superDance 0.8s infinite ease-in-out !important;
      filter: drop-shadow(0 0 25px white); 
    }

    @keyframes superDance {
      0%   { transform: translate(-50%, -50%) scale(4.5) rotate(0deg); }
      25%  { transform: translate(-50%, -50%) scale(4.8) rotate(-8deg); }
      50%  { transform: translate(-50%, -50%) scale(4.5) rotate(0deg) translateY(-20px); } 
      75%  { transform: translate(-50%, -50%) scale(4.8) rotate(8deg); }
      100% { transform: translate(-50%, -50%) scale(4.5) rotate(0deg); }
    }

    .hidden { display: none !important; }
    .waiting { opacity: 0; } 
  </style>
</head>
<body>
  <div id="status">CARGANDO...</div>
  <div id="container"></div>

  <script>
    // --- CONFIGURACIÓN ---
    const CHANNEL = 'laumehdi'; 
    const LIFE_TIME_MINUTES = 50; 
    // ---------------------

    const LIFE_TIME_MS = LIFE_TIME_MINUTES * 60 * 1000;
    const colors = ['transparent','#000000','#aa0000','#00aa00','#aa5500','#0000aa','#aa00aa','#00aaaa','#aaaaaa','#555555','#ff5555','#55ff55','#ffff55','#5555ff','#ff55ff','#55ffff','#ffffff'];
    
    let drawings = []; 
    let testMode = false;
    let subQueue = [];
    let isShowcaseBusy = false;
    let ws = null;
    let reconnectInterval = null;
    let activeCodes = new Set(); 

    // --- CARRILES COMPACTOS (25% Superior) ---
    const LANES = [5, 35, 65, 95]; 
    const SPEEDS = [2, 3.5, 2.5, 4.5];
    const Z_INDEXES = [5, 20, 10, 30];

    // ANIMACIÓN
    function animate() {
      const now = Date.now();

      for (let i = drawings.length - 1; i >= 0; i--) {
        let d = drawings[i];
        
        if (d.el.classList.contains('showcase') || d.el.classList.contains('hidden')) continue;
        
        if (d.el.classList.contains('waiting')) {
             d.el.style.transform = 'translate3d(-500px, -500px, 0)';
             continue;
        }

        // --- LÓGICA DE MUERTE POR DISPARO (FEATHER FALL / PLUMA) ---
        if (d.featherFalling) {
            d.featherTimer += 0.12; 
            d.y += 3.5;             

            const sway = Math.sin(d.featherTimer) * 60; 
            d.x = d.originX + sway;

            d.rot = Math.cos(d.featherTimer) * 20; 

            d.el.style.transform = 'translate3d(' + d.x + 'px, ' + d.y + 'px, 0) rotate(' + d.rot + 'deg)';
            
            if (d.y > 1200) {
                d.el.remove();
                if(d.code) activeCodes.delete(d.code);
                drawings.splice(i, 1);
            }
            continue; 
        }

        // --- MUERTE NATURAL (TIEMPO DE VIDA) ---
        if (!d.dying && !testMode && (now - d.createdAt > LIFE_TIME_MS)) {
            d.dying = true;
            d.vy = 0; d.rot = 0;
        }

        if (d.dying) {
            d.vy += 0.5; 
            d.y += d.vy; 
            d.rot += 5;
            d.el.style.transform = 'translate3d(' + d.x + 'px, ' + d.y + 'px, 0) rotate(' + d.rot + 'deg)';
            d.el.style.opacity = (1 - (d.y / 1500)); 

            if (d.y > 1200) {
                d.el.remove();
                if(d.code) activeCodes.delete(d.code);
                drawings.splice(i, 1);
                continue;
            }
        } else {
            // Movimiento Normal Horizontal
            d.x += d.speed;
            if (d.x > 2200) { 
              let minX = -200;
              for (let j = 0; j < drawings.length; j++) {
                if (drawings[j].lane === d.lane && drawings[j].x < minX) {
                  minX = drawings[j].x;
                }
              }
              d.x = minX - 300; 
            }
            d.el.style.transform = 'translate3d(' + d.x + 'px, ' + d.y + 'px, 0)';
        }
      }
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // CONEXIÓN
    function connectTwitch() {
      if (ws) { try { ws.close(); } catch(e){} }
      
      const statusEl = document.getElementById('status');
      statusEl.style.display = 'block';
      
      statusEl.innerText = "CONECTANDO A " + CHANNEL.toUpperCase() + "...";
      statusEl.style.color = "#ffcc00";

      ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

      ws.onopen = function() {
        console.log("WS Conectado");
        statusEl.innerText = "¡CONECTADO!";
        statusEl.style.color = "#00ff00"; 
        setTimeout(function() { statusEl.style.display = 'none'; }, 3000);
        
        ws.send('CAP REQ :twitch.tv/tags');
        ws.send('PASS oauth:none');
        ws.send('NICK justinfan' + Math.floor(Math.random()*99999));
        ws.send('JOIN #' + CHANNEL.toLowerCase());
        
        if(reconnectInterval) clearInterval(reconnectInterval);
      };

      ws.onerror = function(e) {
        statusEl.innerText = "REINTENTANDO...";
        statusEl.style.color = "red";
      };

      ws.onclose = function() {
        statusEl.innerText = "DESCONECTADO";
        statusEl.style.color = "red";
        reconnectInterval = setTimeout(connectTwitch, 3000);
      };

      ws.onmessage = function(e) {
        handleMessage(e.data);
      };
    }

    function handleMessage(data) {
      if (data.indexOf('PING') !== -1) { ws.send('PONG :tmi.twitch.tv'); return; }

      if (data.indexOf('PRIVMSG') !== -1) {
        const parts = data.split('PRIVMSG #' + CHANNEL.toLowerCase() + ' :');
        if (!parts[1]) return;
        
        const msg = parts[1].trim();
        const rawTags = data.split('PRIVMSG')[0];
        const userMatch = data.match(/:(\w+)!/);
        const user = userMatch ? userMatch[1].toLowerCase() : 'unknown';
        
        const isSub = rawTags.indexOf('subscriber=1') !== -1 || rawTags.indexOf('badges=subscriber') !== -1 || rawTags.indexOf('/founder') !== -1;
        const isAdmin = (user === CHANNEL.toLowerCase());

        if (msg.indexOf('!dibujar ') === 0) {
          const codeParts = msg.substring(9).trim().split(' ');
          const code = codeParts[0]; 
          if(code) createDrawing(user, code, isSub, false);
        } else if (msg.indexOf('!borrar') === 0) {
          const splitMsg = msg.split(' ');
          const target = splitMsg[1] ? splitMsg[1].replace('@','') : user;
          removeDrawing(isAdmin ? target : user);
        } else if (msg === '!limpiartodo' && isAdmin) {
          clearAll();
        } else if (msg === '!testpixel' && isAdmin) {
          toggleTest();
        } else if (msg === '!disparar' && isAdmin) {
          shootRandomDrawing();
        }
      }
    }

    // --- FUNCIÓN DE DIBUJO ---
    function createDrawing(user, fullCode, isSub, isTest, forceX) {
      if (!isTest && activeCodes.has(fullCode)) return;

      try {
        let pixelData = [];
        let finalPalette = []; 
        const isV2 = fullCode.indexOf('v2') === 0; 

        if (isV2) {
          // LÓGICA V2 (NUEVA)
          const cleanCode = fullCode.substring(2);
          const parts = cleanCode.split('_');
          const headerHex = parts[0];
          const payload = parts[1];
          if (!headerHex || !payload) return;

          // 1. Construir Paleta Local
          finalPalette.push('transparent'); 
          for (let i = 0; i < headerHex.length; i += 6) {
            finalPalette.push('#' + headerHex.substring(i, i+6));
          }

          // 2. Decodificar Pixeles
          const binaryString = atob(payload);
          for (let i = 0; i < binaryString.length; i++) {
            const byte = binaryString.charCodeAt(i);
            pixelData.push((byte >> 4) & 0x0F);
            pixelData.push(byte & 0x0F);
          }

        } else {
          // LÓGICA V1 (ANTIGUA)
          if(fullCode.indexOf('_') === -1) return;
          const parts = fullCode.split('_');
          const header = parts[0];
          const payload = parts[1];
          if (!header || !payload) return;

          for (let i = 0; i < payload.length; i += 2) {
            const colorIdx = parseInt(payload[i], 16);
            const count = parseInt(payload[i+1], 36);
            if(isNaN(colorIdx) || isNaN(count)) continue;
            for (let j = 0; j < count; j++) {
              pixelData.push(colorIdx);
            }
          }

          const usedColorsIdx = [];
          for(let i=0; i < header.length; i++) {
            if (header[i] === '1' && header[i+1] === '0') { usedColorsIdx.push(16); i++; }
            else { usedColorsIdx.push(parseInt(header[i], 16)); }
          }
          
          for(let k=0; k<usedColorsIdx.length; k++) {
              finalPalette.push(colors[usedColorsIdx[k]] || 'transparent');
          }
        }

        // --- RENDERIZADO ---
        const itemEl = document.createElement('div');
        itemEl.className = 'item';
        
        const canvas = document.createElement('canvas');
        canvas.width = 16; canvas.height = 16;
        const ctx = canvas.getContext('2d');
        
        ctx.clearRect(0, 0, 16, 16); // Limpieza de seguridad

        for (let k = 0; k < pixelData.length; k++) {
           const colorIndex = pixelData[k];
           
           if (isV2) {
               if (colorIndex > 0 && colorIndex < finalPalette.length) {
                   ctx.fillStyle = finalPalette[colorIndex];
                   ctx.fillRect(k % 16, Math.floor(k / 16), 1, 1);
               }
           } else {
               if(colorIndex < finalPalette.length) {
                   const color = finalPalette[colorIndex];
                   if(color !== 'transparent') {
                       ctx.fillStyle = color;
                       ctx.fillRect(k % 16, Math.floor(k / 16), 1, 1);
                   }
               }
           }
        }

        // --- LÓGICA DE ESTADOS Y ANIMACIONES ---
        if (isSub) {
            // Es Sub: Animación Glow y va a la cola de espera
            itemEl.classList.add('is-sub');
            if (!isTest) itemEl.classList.add('waiting');
        } else {
            // NO es Sub: Animación de SALTO de bienvenida
            if (!isTest) {
                itemEl.classList.add('jumping');
                // Quitar la clase después de 10 segundos
                setTimeout(() => {
                    if (itemEl) itemEl.classList.remove('jumping');
                }, 16000);
            }
        }

        if (testMode && !isTest) itemEl.classList.add('hidden');

        itemEl.appendChild(canvas);

        const nickEl = document.createElement('div');
        nickEl.className = 'nick'; 
        nickEl.innerText = (isSub ? '⭐ ' : '') + user;
        itemEl.appendChild(nickEl);
        
        const laneIdx = drawings.length % 4;
        itemEl.style.zIndex = Z_INDEXES[laneIdx]; 
        document.getElementById('container').appendChild(itemEl);

        let obj = {
          el: itemEl,
          user: user,
          code: fullCode,
          lane: laneIdx,
          speed: SPEEDS[laneIdx],
          y: LANES[laneIdx],
          x: forceX !== undefined ? forceX : -400,
          isTest: isTest,
          createdAt: Date.now(),
          dying: false,
          featherFalling: false,
          featherTimer: 0,
          originX: 0
        };

        if (forceX === undefined) {
          let min = -200;
          drawings.forEach(function(d) { 
             if(d.lane === laneIdx && d.x < min) min = d.x; 
          });
          obj.x = min - 300;
        }

        drawings.push(obj);

        if (!isTest) {
          activeCodes.add(fullCode);
          if (isSub) { subQueue.push(obj); processQueue(); }
        }
      } catch(e) { console.error("Error al crear dibujo:", e); }
    }

    function shootRandomDrawing() {
      const candidates = drawings.filter(d => 
        !d.dying && 
        !d.featherFalling && 
        !d.el.classList.contains('hidden') && 
        !d.el.classList.contains('showcase') &&
        !d.el.classList.contains('waiting')
      );

      if (candidates.length === 0) return; 

      const victim = candidates[Math.floor(Math.random() * candidates.length)];
      victim.featherFalling = true;
      victim.featherTimer = 0; 
      victim.originX = victim.x; 
    }

    function toggleTest() {
      if (!testMode) {
        testMode = true;
        drawings.forEach(function(d) { if(!d.isTest) d.el.classList.add('hidden'); });
        const code = "0ce_0m17081205120k210623042501220121042103210223012103230221022103220321032101230322022103210121062102210523022302210922042102120f150g170i";
        for (let i = 0; i < 20; i++) {
          createDrawing('Bot_' + i, code, (i % 3 === 0), true, (Math.random() * 1900));
        }
      } else {
        testMode = false;
        let newDrawings = [];
        for(let k=0; k<drawings.length; k++){
            let d = drawings[k];
            if(d.isTest) { d.el.remove(); } 
            else { d.el.classList.remove('hidden'); newDrawings.push(d); }
        }
        drawings = newDrawings;
      }
    }

    function processQueue() {
      if (!isShowcaseBusy && subQueue.length > 0) {
        isShowcaseBusy = true;
        const current = subQueue.shift();
        
        current.el.classList.remove('waiting', 'hidden');
        current.el.classList.add('showcase');
        current.el.style.transform = ''; 
        
        setTimeout(function() {
          current.el.classList.remove('showcase');
          let min = -200;
          drawings.forEach(function(d) { if(d.lane === current.lane && d.x < min) min = d.x; });
          current.x = min - 350;
          
          isShowcaseBusy = false;
          processQueue();
        }, 10000); 
      }
    }

    function clearAll() {
      drawings.forEach(function(d) { d.el.remove(); });
      drawings = []; 
      activeCodes.clear();
      subQueue = []; 
      isShowcaseBusy = false;
    }

    function removeDrawing(u) {
      for (let i = drawings.length - 1; i >= 0; i--) {
        if (drawings[i].user === u) {
          drawings[i].el.remove();
          if (drawings[i].code) activeCodes.delete(drawings[i].code);
          drawings.splice(i, 1);
        }
      }
    }

    connectTwitch();
  </script>
</body>
</html>
